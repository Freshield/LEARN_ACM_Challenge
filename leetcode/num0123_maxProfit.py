#coding=utf-8
"""
@Author: Freshield
@Contact: yangyufresh@163.com
@File: num0123_maxProfit.py
@Time: 2020-04-21 11:08
@Last_update: 2020-04-21 11:08
@Desc: None
@==============================================@
@      _____             _   _     _   _       @
@     |   __|___ ___ ___| |_|_|___| |_| |      @
@     |   __|  _| -_|_ -|   | | -_| | . |      @
@     |__|  |_| |___|___|_|_|_|___|_|___|      @
@                                    Freshield @
@==============================================@
"""
import numpy as np


class Solution:
    """
    给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。
    设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。
    注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
    解法：使用动态规划的方法
    1. dp的含义：dp[i, 持有的股票, 交易的次数]，dp代表当前最大收益
    2. dp的关系公式：
        dp[i, 0, 0]代表没有股票也不交易，所以为0
        dp[i, 0, 1]代表交易了一次，有两种情况
            dp[i-1, 0, 1]之前就交易完了或者dp[i-1, 1, 0] + prices[i]刚卖
        dp[i, 0, 2]代表交易了两次，有两种情况
            dp[i-1, 0, 2]之前就交易完了或者dp[i-1, 1, 1] + prices[i]刚卖
        dp[i, 1, 0]代表持有一个股票，有两种情况
            dp[i-1, 1, 0]之前就持有或者dp[i-1, 0, 0] - prices[i]刚买
        dp[i, 1, 1]代表持有一个股票并完成过一次交易，有两种情况
            dp[i-1, 1, 1]之前就持有或者dp[i-1, 0, 1] - prices[i]刚买
        dp[i, 1, 2]代表交易了2次，却还持有股票，不被允许，为-1e6
    3. dp初始化：
        dp[0,0,1] = -1e6不可能直接就完成了一次交易 dp[0,0,2]=-1e6
        dp[0,1,0] = -prices[0]代表一开始就买, dp[0,1,1] = -1e6
        dp[1,1,1] = -1e6不可能第一次就完成两个操作, dp[1,0,2]=-1e6
    4. dp遍历流程：
        i依赖于左边，从小到大遍历
    """
    def maxProfit(self, prices):
        """
        整体流程：
        1. 生成dp矩阵和相关变量
        2. 初始化dp矩阵
        3. 遍历i
        4. 更新dp矩阵值
        5. 返回最大收益，注意要返回大于等于0
        """
        if len(prices) == 0:
            return 0

        # 1. 生成dp矩阵和相关变量
        dp = np.zeros((len(prices), 2, 3), dtype=np.int32)
        # 2. 初始化dp矩阵
        dp[:, 0, 0] = 0
        dp[:, 1, 2] = -1e6
        dp[0, 0, 1] = -1e6
        dp[0, 0, 2] = -1e6
        dp[0, 1, 0] = -prices[0]
        dp[0, 1, 1] = -1e6
        # 3. 遍历i
        for i in range(1, len(prices)):
            # 4. 更新dp矩阵值
            dp[i, 0, 1] = max(dp[i-1, 0, 1], dp[i-1, 1, 0] + prices[i])
            dp[i, 0, 2] = max(dp[i-1, 0, 2], dp[i-1, 1, 1] + prices[i])
            dp[i, 1, 0] = max(dp[i-1, 1, 0], dp[i-1, 0, 0] - prices[i])
            dp[i, 1, 1] = max(dp[i-1, 1, 1], dp[i-1, 0, 1] - prices[i])
            if i == 1:
                dp[i, 0, 2] = -1e6
                dp[i, 1, 1] = -1e6

        # 5. 返回最大收益，注意要返回大于等于0
        return int(max(dp[-1].max(), 0))


if __name__ == '__main__':
    # prices = [3, 3, 5, 0, 0, 3, 1, 4]
    prices = [1, 2, 3, 4, 5]
    prices = [7, 6, 4, 3, 1]
    print(Solution().maxProfit(prices))